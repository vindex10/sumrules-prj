"""@package Batch
Stores a class needed to distribute jobs at cluster.
"""
import os
import datetime

from sumrules.misc.ConfigManager import ConfigManager
from sumrules.Config import Config

class Batch(object):
    """ Distribute jobs at cluster with this class.
        
        Attributes:
            config: dict of batch's configs.
                * outputDir - name of dir to store batch's outputs.
                * prjPath - path to sumrules-prj root.
                * testName - name of the test to be run.
                * tplPath - path to config to be parallelized.
                * suffix - name of subdir to distinguish different runs.
                * shift - start enumeration of jobs not from 0, but from `shift`.
                * logscale - whether to distribute in log scale.
                * dry - if True, then only generate configs, no calling.
            ditor: function which will break config into parts, 1 per job.
            call: a function which will call `qsub` or `slurm` to start the job.
    """

    def __init__(self, ditor, call):
        """ Init.
            
            Args:
                ditor: function to set self.ditor
                call: function to set self.call
        """
        self._tpl = dict()
        self.config = Config({"outputDir": "output"
                             ,"prjPath": "."
                             ,"testName": ""
                             ,"tplPath": "template.cfg"
                             ,"suffix": datetime.datetime.now().strftime("%Y%m%d%H%M%S")
                             ,"shift": 0
                             ,"logscale": True
                             ,"dry": False
                        })
        self.ditor = ditor
        self.call = call
    
    def readFile(self, f):
        """ Read config file, and store fields as dict into `self._tpl`.
            
            Args:   
                f: file descriptor to read from.

            Returns:
                Nothing.
        """
        for line in f:
            matching = ConfigManager._cfgre.match(line)
            if not matching:
                continue
            pair = [v for v in matching.groups()\
                        if v is not None]
            if len(pair) > 0:
                self._tpl.update({
                    pair[0]: ConfigManager._parseStr(pair[1])
                })

    def path(self, *paths):
        """ Analog for os.path.join, but relatively to test's `outputDir`
            
            Args:
                *paths: pathes to join into resulting one.

            Returns:
                String. The path.
        """
        return os.path.join(self.config["outputDir"]\
                           ,self.config["suffix"]\
                           ,*paths)

    def envInit(self):
        """ Create dirs if not exist
            
            Create dirs needed for batch output, if they don't exist.

            Returns:
                Nothing.
        """
        dirs = ("logs", "output", "configs")
        if not os.path.isdir(self.path()):
            os.makedirs(self.path())

        for d in dirs:
            if not os.path.isdir(self.path(d)):
                os.makedirs(self.path(d))

    def writeConfigs(self, spec):
        """ Write distributed configs to files.
            
            Args:
                spec: specification for generation those configs with ditor.

            Returns:
                List of dicts. Config files for all jobs.
        """
        cfgs = list()
        for cfg in self.ditor(self._tpl, spec, self.config.copy()):
            config = "\n".join((k+" = "+str(v) for k,v in cfg.items()))
            cfgs.append(cfg)
            with open(self.path("configs", "%s.conf" % cfg["TEST_title"]), "w") as f:
                f.write(config+"\n")
        return cfgs

    def doCalls(self, cfgs):
        """ Do calls for each generated and stored config.
            
            Use list of dicts corresponding to configs generated by
            `self.writeConfigs`, to run jobs at cluster.
            
            Args:
                cfgs: list of dicts. Output of `self.writeConfigs`.
            
            Returns:
                Nothing.
        """
        for cfg in cfgs:
            self.call(self.config["prjPath"]\
                     ,self.config["testName"]\
                     ,cfg["TEST_title"]\
                     ,self.path("configs", "%s.conf" % cfg["TEST_title"])
                     ,cfg["TECH_numThreads"]
                     ,self.path("logs", "%s.log" % cfg["TEST_title"])
                     ,dry=self.config["dry"])

    def run(self, spec):
        """ Run batch.
            
            Args:
                spec: specification for generation those configs with ditor.
        """
        with open(self.config["tplPath"], "r") as f:
            self.readFile(f)
        self.envInit()
        cfgs = self.writeConfigs(spec)
        self.doCalls(cfgs)

